<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>fbx 模型加载示例</title>
  <style>
    body {
      margin: 0;
      overflow: hidden;
    }

    #canvas {
      display: block;
      width: 100%;
      height: 100%;
      margin: 0;
      padding: 0;
      border: none;
    }
  </style>
</head>

<body>
  <div id="idcanvas">
    <form action="/upload" id='upload-form' method="POST" enctype="multipart/form-data">
      <input type="file" id='file-input' name="file">
      <input type="submit" value="Upload File">
    </form>
  </div>
  <script type="importmap">
    {
        "imports": {
            "three": "/static/build/three.module.js"
        }
    }
</script>

  <script type="module">
    import * as THREE from 'three';
    import { OrbitControls } from '/static/examples/jsm/controls/OrbitControls.js';
    import { FBXLoader } from '/static/examples/jsm/loaders/FBXLoader.js';
    import { TransformControls } from '/static/examples/jsm/controls/TransformControls.js';
    import { CCDIKSolver, CCDIKHelper } from '/static/examples/jsm/animation/CCDIKSolver.js';

    // declare variables
    let scene, renderer, camera, controls, skeletonHelper, axesHelper, skinnedMesh, IKSolver, IKsolvers;
    let ambientLight, directionalLight;

    let shouldUpdateIK = false; // 初始值为false
    let transformControls, transformControls2, transformControls3, transformControls4;
    const rootbones = {};//Bone array
    // 定义四肢的IK链数据结构
    const limbIKData = {
      leftArm: {
        target: '左手控制_L',
        effector: 'mixamorigLeftHand',
        links: ['mixamorigLeftForeArm', 'mixamorigLeftArm']
      },
      rightArm: {
        target: '右手控制_R',
        effector: 'mixamorigRightHand',
        links: ['mixamorigRightForeArm', 'mixamorigRightArm']
      },
      leftLeg: {
        target: '左腿控制_L',
        effector: 'mixamorigLeftFoot',
        links: ['mixamorigLeftLeg', 'mixamorigLeftUpLeg']
      },
      rightLeg: {
        target: '右腿控制_R',
        effector: 'mixamorigRightFoot',
        links: ['mixamorigRightLeg', 'mixamorigRightUpLeg']
      }
      // 更多的肢体可以按照此格式继续添加
    };
    init();
    loadModel();
    render();

    function init() {
      scene = new THREE.Scene();

      renderer = new THREE.WebGLRenderer({ antialias: true });
      renderer.setSize(window.innerWidth, window.innerHeight);
      renderer.setClearColor(0x000000, 0); // 设定清除颜色与透明度
      document.getElementById('idcanvas').appendChild(renderer.domElement);
      // 初始化场景
      initBasicSceneElements();
    }

    function initBasicSceneElements() {

      axesHelper = new THREE.AxesHelper(50);
      scene.add(axesHelper);

      ambientLight = new THREE.AmbientLight(0xffffff, 2);
      scene.add(ambientLight);

      directionalLight = new THREE.DirectionalLight(0xffffff, 0.5);
      directionalLight.position.set(10, 10, 10);
      scene.add(directionalLight);

      camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 2000);
      camera.position.set(100, 50, 100);
      camera.lookAt(scene.position);

      controls = new OrbitControls(camera, renderer.domElement);
      controls.enableDamping = true;
      controls.dampingFactor = 0.05;
    }

    function loadModel(modelPath = '/static/resources/models/pg_ik_Modify_parent.fbx') {
      const loader = new FBXLoader();
      loader.load(modelPath, function (pg) {
        pg.rotation.set(0, 0.7, 0);
        pg.position.set(0, -100, 0);
        scene.add(pg);
        console.log(scene);
        pg.traverse(function (child) {
          if (child.isMesh) {
            // 检查子对象是否有材质和贴图
            const material = child.material;
            if (material && material.map) {
              console.log(`贴图已加载: ${material.map.name}`);
            } else {
              console.log('此子对象没有贴图。');
            }
          }

          if (child.isSkinnedMesh) {
            skinnedMesh = child; // 确保这一行成功找到了网格
            // 找到skinnedMesh后，再将pg添加到场景中
            scene.add(pg);
            IKsolvers = setupIKSolvers(skinnedMesh, limbIKData); // 现在可以初始化IKsolvers

            // 使用新的创建控制器的方法
            rootbones.右手控制_R = pg.getObjectByName('右手控制_R');
            rootbones.左手控制_L = pg.getObjectByName('左手控制_L');
            rootbones.右腿控制_R = pg.getObjectByName('右腿控制_R');
            rootbones.左腿控制_L = pg.getObjectByName('左腿控制_L');

            transformControls = createTransformControl('右手控制_R');
            transformControls2 = createTransformControl('左手控制_L');
            transformControls3 = createTransformControl('右腿控制_R');
            transformControls4 = createTransformControl('左腿控制_L');
          }
        }
        );
      });
    }

    document.getElementById('upload-form').addEventListener('submit', function (e) {
      e.preventDefault();
      const fileInput = document.getElementById('file-input');
      const file = fileInput.files[0];

      if (file) {
        const formData = new FormData();
        formData.append('file', file);

        // 发送文件到服务器
        fetch('/upload', {
          method: 'POST',
          body: formData
        })
          .then(response => response.json())
          .then(data => {
            if (data.success) {
              // 文件上传成功，根据服务器响应的数据加载模型
              alert('文件上传成功');
              //  clearScene(data.model_path);
              clearScene(data.model_path)

            } else {
              alert('文件上传失败');
            }
          })
          .catch(error => {
            console.error('上传文件时出错:', error);
            alert('上传文件时出错');
          });
      }
    });

    function clearScene(modelPath) {
      while (scene.children.length > 0) {
        let child = scene.children[0];
        if (child.isMesh) {
          child.geometry.dispose();
        }
        scene.remove(child);
      }
      // 重置相关的变量
      skinnedMesh = undefined;
      IKsolvers = undefined;
      // ...其余代码
      initBasicSceneElements()
      loadModel(modelPath)
    }

    function createTransformControl(boneName) {
      let control = new TransformControls(camera, renderer.domElement);
      control.size = 0.75;
      control.attach(rootbones[boneName]);
      scene.add(control);
      control.setMode('translate');

      // 添加鼠标事件监听器，用于开启和关闭IK更新
      control.addEventListener('mouseDown', () => {
        controls.enabled = false;
        shouldUpdateIK = true;
      });
      control.addEventListener('mouseUp', () => {
        controls.enabled = true;
        shouldUpdateIK = false;
      });

      return control;
    }

    function setupIKSolvers(skinnedMesh, limbIKData) {
      const IKsolvers = {};

      for (const limbName in limbIKData) {
        const limb = limbIKData[limbName];
        const boneArray = skinnedMesh.skeleton.bones;

        // 检查链的目标和效应器是否存在
        const targetBone = boneArray.find(bone => bone.name === limb.target);
        const effectorBone = boneArray.find(bone => bone.name === limb.effector);
        if (!targetBone || !effectorBone) {
          console.error(`IK setup error: Target or effector bone not found for ${limbName}.`);
          continue; // 跳过当前肢体的IK设置
        }

        const links = limb.links.map(linkName => {
          const linkBone = boneArray.find(bone => bone.name === linkName);
          if (!linkBone) {
            console.error(`IK setup error: Link bone not found: ${linkName}.`);
            return null; // 返回null作为标记
          }
          return { index: boneArray.indexOf(linkBone) };
        }).filter(link => link !== null); // 过滤掉任何未找到的链接

        // 如果链接中有未找到的骨骼，则跳过IK的设置
        if (links.length !== limb.links.length) {
          console.error(`IK setup error: Not all link bones found for ${limbName}.`);
          continue;
        }

        // 创建IK链的数据结构
        const ik = {
          target: boneArray.indexOf(targetBone),
          effector: boneArray.indexOf(effectorBone),
          links: links
        };

        // 使用CCDIKSolver初始化IK解算器
        IKsolvers[limbName] = new CCDIKSolver(skinnedMesh, [ik]);
        const ccdikhelper = new CCDIKHelper(skinnedMesh, [ik], 0.01);
        scene.add(ccdikhelper);
      }

      return IKsolvers;
    }

    function render() {
      requestAnimationFrame(render);
      // 更新IK
      if (shouldUpdateIK && IKsolvers) {
        for (const solver of Object.values(IKsolvers)) {
          solver.update();
        }
      }
      renderer.render(scene, camera);
    }

    window.onresize = function () {
      const width = window.innerWidth;
      const height = window.innerHeight;
      renderer.setSize(width, height);
      camera.aspect = width / height;
      camera.updateProjectionMatrix();
      renderer.render(scene, camera);
    };

  </script>



</body>

</html>